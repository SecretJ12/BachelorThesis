
\section{Schema} \label{chapter:impl_schema}
For first-order functions, the translation schema equals the schema used by Nipkow \parencite{fds}.
All cases defined by Sands also equal this schema \parencite{sands}.
Therefore, the proof described in \autoref{chapter:formal} holds for this restricted part of the schema.

Just like Nipkow, we treat some functions differently.
Here, those functions are called zero functions.
They include constructors and some basic mathematical operations and comparisons.
Additionally, the user can mark any function as zero function.
The command and the functions marked as zero by default can be found in \autoref{chapter:commands}.
Only functions taking a constant amount of time should be marked as zero functions.
The user is obliged to mark only correct functions.
\Sectionref{chapter:nonconstant_zeros} contains a discussion about this.

Additionally, the schema was extended for higher-order functions similar to Sands as described in \autoref{chapter:higher_order}.
Every argument being a function will be replaced by a pair of the function and its timing function.
We first need to define two helper functions to deal with those constructs.
$\mathcal{N}$ will replace all occurences of a passed function $f$ by $\texttt{(fst f)}$.
As a result, we get an expression evaluating to the normal result as in the original function.
The definition can be found in \autoref{fig:schema_N}.
The function $\mathcal{A}$ converts an expression for being passed as an argument to a timing function.
All defined constants of non-primitive functions will be converted into the wanted pair.
For primitive functions, the second argument will be a lambda, taking the same number of arguments and returning $0$.
We do not need to change something for passed functions, as they are already pairs.
All the other expressions will be converted by the function $\mathcal{N}$ as they should be evaluated as normal.
As we do not support curried functions, those expressions cannot evaluate to a function and, therefore, will not create problems.
The definition for $\mathcal{A}$ is described in \autoref{fig:schema_A}.
\begin{figure}
\begin{align*}
  \mathcal{N}\llbracket f\rrbracket &= (\texttt{fun}\ f) &&\text{| passed function}\\
  \mathcal{N}\llbracket e_{1}\ \$\ e_{n}\rrbracket &= \mathcal{N}\llbracket e_{1}\rrbracket\ \$\ \mathcal{N}\llbracket e_{2}\rrbracket &&\text{| other expressions}
\end{align*}
\caption{Handling function application for normal evaluation}
\label{fig:schema_N}
\end{figure}

\begin{figure}
  \begin{align*}
    \mathcal{A}\llbracket f\rrbracket &= (f,\ T\_f) &&\text{| identifier of a defined non-primitive function}\\
    \mathcal{A}\llbracket f\rrbracket &= (f, (\lambda x\ \dots\ z.\ 0)) &&\text{| identifier of a defined primitive function}\\
    \mathcal{A}\llbracket f\rrbracket &= f &&\text{| passed function}\\
    \mathcal{A}\llbracket e\rrbracket &= \mathcal{N}\llbracket e\rrbracket &&\text{| other expressions}
  \end{align*}
  \caption{Preparing arguments for timing functions}
  \label{fig:schema_A}
\end{figure}

We now define the function $\mathcal{F}$, which converts a given function application into the application of the timing function.
All zero functions will be translated to $0$ as their evaluation does not cost anything by definition.
Defined functions get translated to the application of their timing function.
All functions given as arguments should also be translated to an application of their timing function.
As those arguments are now represented as a pair, we need to use the second element to receive the timing function.
We use the previously defined function $\mathcal{A}$ to prepare arguments for the timing function.
We will handle the cost of the arguments in the next step.
The schema is defined in \autoref{fig:schema_F}.
\begin{figure}
\begin{align*}
  \mathcal{F}\llbracket f\ a_{1}\ \dots\ a_{n}\rrbracket &= 0 &&\text{| Zero function}\\
  \mathcal{F}\llbracket f\ a_{1}\ \dots\ a_{n}\rrbracket &= (T\_f\ \mathcal{A}\llbracket a_{1}\rrbracket\ \dots\ \mathcal{A}\llbracket a_{n}\rrbracket) &&\text{| Defined function}\\
  \mathcal{F}\llbracket f\ a_{1}\ \dots\ a_{n}\rrbracket &= ((snd\ f)\ \mathcal{A}\llbracket a_{1}\rrbracket\ \dots\ \mathcal{A}\llbracket a_{n}\rrbracket) &&\text{| Passed function}
\end{align*}
\caption{Handling function applications}
\label{fig:schema_F}
\end{figure}

$\mathcal{T}$ is the main conversion function, defined in \autoref{fig:schema_T}.
It converts expressions just as defined by Nipkow.
The only exceptions are expressions that need to be evaluated normally.
As the schema provided by Nipkow is restricted to first-order functions, we need to pass those expressions through our defined function $\mathcal{N}$.
This happens in the cases of $\texttt{if-else}$, $\texttt{case}$ and $\texttt{let}$.
\begin{figure}
\begin{align*}
  &\mathcal{T}\llbracket c\rrbracket &&= 0\\
  &\mathcal{T}\llbracket f\ a_{1}\ \dots\ a_{n}\rrbracket &&= \mathcal{F}\llbracket T\_f\ a_{1}\ \dots\ a_{n}\rrbracket + \mathcal{T}\llbracket a_{1}\rrbracket + \dots + \mathcal{T}\llbracket a_{n}\rrbracket\\
  &\mathcal{T}\llbracket \text{if}\ c\ \text{then}\ et\ \text{else}\ ef\rrbracket &&= \mathcal{T}\llbracket c\rrbracket + (\text{if}\ \mathcal{N}\llbracket c\rrbracket\ \text{then}\ \mathcal{T}\llbracket et\rrbracket\ \text{else}\ \mathcal{T}\llbracket ef\rrbracket)\\
  &\mathcal{T}\llbracket \text{case}\ e\ \text{of}\ c_{1} \Rightarrow e_{1}\ |\ \dots\ |\ c_{n}\Rightarrow e_{n}\rrbracket &&= \mathcal{T}\llbracket c\rrbracket + \\
  & &&\ \ \ \ \ (\text{case}\ \mathcal{N}\llbracket e\rrbracket\ \text{of}\ c_{1}\Rightarrow\mathcal{T}\llbracket e_{1}\rrbracket\ |\ \dots\ |\ c_{n} \Rightarrow \mathcal{T}\llbracket e_{n}\rrbracket)\\
  &\mathcal{T}\llbracket \text{let}\ x = e_{1}\ \text{in}\ e_{2}\rrbracket &&= \mathcal{T}\llbracket e_{1}\rrbracket + (\text{let}\ x = \mathcal{N}\llbracket e_{1}\rrbracket\ \text{in}\ \mathcal{T}\llbracket e_{2}\rrbracket)
\end{align*}
  \caption{Main conversion schema for expressions}
  \label{fig:schema_T}
\end{figure}

Finally, we can define the function $\mathcal{C}$ transforming function definitions.
The converter differs between recursive and non-recursive functions.
Recursive functions will be translated with a leading $1+$, while this is left out at non-recursive functions.
This can be justified as the function call only represents a constant at non-recursive functions.
Therefore, the asymptotic running time class does not change.
The schema is defined in \autoref{fig:schema_C}.

\begin{figure}
  \begin{align*}
    \mathcal{C}\llbracket f\ a_1\ \dots\ a_n &= e\rrbracket = (T\_f\ a_{1}\ \dots\ a_{n} = \mathcal{T}\llbracket e\rrbracket) &&\text{| non-recursive}\\
    \mathcal{C}\llbracket f\ a_1\ \dots\ a_n &= e\rrbracket = (T\_f\ a_{1}\ \dots\ a_{n} = 1 + \mathcal{T}\llbracket e\rrbracket) &&\text{| recursive}
  \end{align*}
  \caption{Conversion of function definitions}
  \label{fig:schema_C}
\end{figure}
