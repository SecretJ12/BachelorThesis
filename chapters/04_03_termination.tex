

\section{Termination proof} \label{chapter:termination}

The command $\texttt{define\_time\_fun}$ tries to automatically proof termination of the timing function.
Just as the name of the command suggests the first try is similar to the command $\texttt{fun}$.
Here the tactic $\texttt{lexicographic\_order}$ is used.
This also happens first in the conversion command.

We now look at the following function $\texttt{sum}$.
\begin{lstlisting}[language=isabelle,mathescape=true]
  function sum :: "nat => nat => nat" where
    "sum i j = (if j $\le$ i then 0 else i + sum (Suc i) j)"
    by pat_completeness auto
  termination
    by (relation "measure ($\lambda$(i,j). j - i)") auto
\end{lstlisting}
Termination cannot be prooved by $\texttt{lexicographic\_order}$ therefore same fails for the timing function.
But as the user has already prooved termination for this function, we could try to convert make use of it.
The second strategy tries to do so in order to cover all the other cases for termination.
In the first step we register the timing function equivalent to using the $\texttt{function}$ command.
\begin{lstlisting}[language=isabelle,mathescape=true,caption=Function registration,label=lst:sum_reg]
  function (domintros) T_sum :: "nat => nat => nat" where
    "T_sum i j = 1 + (if j $\le$ i then 0 else T_sum (Suc i) j)"
    by pat_completeness auto
\end{lstlisting}
In Isabelle every function needs to terminate.
As a result the simp rules are not usable so far.
However we receive another function called $T\_sum\_dom$.
It represents the domain of arguments in which $T\_sum$ terminates.
Therefore it takes the arguments of $T\_sum$ as a tuple and yields $True$ if the function terminates for them and $False$ otherwise.
Based on this the rules psimps are generated.
They state the following: Under the assumption of $T\_sum$ terminating the corresponding simp rule holds.

\begin{figure}[H]
\begin{align*}
  &\texttt{T\_sum\_dom (?i, ?j)}\\
  &\texttt{$\Longrightarrow$ T\_sum ?i ?j = 1 + (if ?j $\le$ ?i then 0 else T\_sum (Suc ?i) ?j)}
\end{align*}
\caption{T\_sum.psimps}
\end{figure}

From this equation we can see how the termination proof works.
In order to obtain the simp rules wee need to show, that $T\_sum\_dom$ holds for every argument.
Before we start with the proof, we need to look at another another set of generated rules.
The domintros rules represent when a function call terminates.
This happens if all the recursive call it does also terminate.
Those rules are not generated by default due to performance resasons, we needed to explicitely pass the option domintros to obtain them.
This happend in the listing \ref{lst:sum_reg}.
For our sum function the domintros rule has the following form.
\begin{figure}[H]
\begin{align*}
  \texttt{($\lnot$ ?j $\le$ ?i $\Longrightarrow$ T\_sum\_dom (Suc ?i, ?j)) $\Longrightarrow$ T\_sum\_dom (?i, ?j)}
\end{align*}
\caption{T\_sum.domintros}
\label{lst:domintros}
\end{figure}

This gives us all the needed rules to proove our goal.
We start by setting up the goal of the form $\texttt{T\_f\_dom (a}_{1}\texttt{,}\dots\texttt{,a}_{n}\texttt{)}$.
On this goal we perform an induction with the induction schema provided by the original function.
This schema was prooved with the termination of the original funciton.
Therefore this is the step where we use the termination proof of the original function.
To argue about the next step we need to look at the translation schema for out timing functions.
Taking the if-else construct as an example, the place where recursive function calls are made don't change.
All function call inside the condition will still be executed without another precondition.
For the function call inside the then and else branche the precondition stays the same, as the condition is not changed.
This justifies why the resulting cases stay close to the original function.
Taking the sum function as an example the following goal is generated.
\begin{align*}
  \texttt{$\bigwedge$i j. ($\lnot$ j $\le$ i $\Longrightarrow$ T\_sum\_dom (Suc i, j)) $\Longrightarrow$ T\_sum\_dom (i,j)}
\end{align*}
As expected it looks similar to the domintros rule shown in listing \ref{lst:domintros}.
With its help we are also able to solve the goal.
In order to support as many cases as possible we use metis as advanced prover for it.
With the just proven goal auto is now able to prove termination.
The whole proof can be found in listing \ref{lst:proof_schema}.
\begin{lstlisting}[language=isabelle,mathescape=true,label=lst:proof_schema,caption=Proof schema over dom with help of original function]
  lemma T_sum_dom: "T_sum_dom (i,j)"
    apply (induction i j rule: sum.induct)
    apply (metis T_sum.domintros)
    done
  termination
    by (auto simp: T_sum_dom)
\end{lstlisting}

Internally auto is used before metis, as it can use some more simplifiers and therefore cover some more edgecases.
For function with multiple equations multiple induction goals will be created.
The automation first tries to solve every goal by the corresponding domintros rule and falls back to all domintros rules in case of failure.
This behaviour reduces the number of ``Unused theorems'' warnings.
Also no named lemma is just for demonstration purposes.
The goal is only used internally and cannot be referenced from the outside.
