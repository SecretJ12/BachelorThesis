
\section{Restrictions} \label{chapter:restrictions}
The converter has some known restrictions.

\subsection{Functions in datatypes}
As described earlier there is a translations for functions being passed as arguments.
Extending this for functions contained in pairs is straight forward, as function type inside a pair can be changed to the needed pair.
The converter supports this automatically.
For arbitrary datatypes this no longer holds.
For example imagine a datatype with a constructor taking a function.
We cannot change the argument to a pair of functions as it is already fixed by the datatype.
Therefore it would be needed create a new datatype taking the mentioned type.
This is no longer in the wanted scope of this command.

\subsection{Operations on datatypes} \label{chapter:nonconstant_zeros}
Most basic operations as the equals operator ``='' are marked as zero function.
For simple datatype as nat we can easily argue that a comparsion can be made in constant time.
This no longer holds for slightly more complicated types as lists.
The exact time for a list would be linear times the time for the type of the contained items in the list.
The command would need to register a timing version for every term the operator could be used with.
Considering fully specified types this would be quite complex, without specified types it's not possible.
Therefore it is the users responsibility to only use those zero operators in timing functions if the constant time can be justified.
For lists this could be the case if one of the comparison sides is a constant as the empty list.

\subsection{Partial application}
As described in chapter \ref{chapter:rel_curried} Sands also proposes a translation schema for curried functions.
This schema cannot be used as Isabelle uses a strict type system.
Trying to define the basic function $\texttt{app'}$ as defined in listing \ref{lst:curried_app'} in Isabelle will fail.
In the then branch the outcome of the func part is returned, while the else branch returns a triple.
The function $\texttt{capp}$ defined in listing \ref{lst:curried_capp} can be registered.
But as the arity counter is not coupled to the timing function itself, the timing function always needs to be of the form $\texttt{'a $\Rightarrow$ nat}$.
This is not a wanted behaviour, as we also want to evaluate the cost of a not fully evaluated function.

To overcome this issue we would need to couple the counter to the number of arguments more closely.
As this would involve a more complex datatype this is not in scope of the conversion command.
